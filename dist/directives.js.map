{
  "version": 3,
  "sources": ["../src/helpers/create-template-directive.ts", "../src/helpers/attrs.ts", "../src/helpers/create-ref.ts", "../src/directives/ref.ts", "../src/directives/text.ts", "../src/helpers/is-plain-object.ts", "../src/h.ts", "../src/helpers/is-parsed-template.ts", "../src/helpers/create-list.ts", "../src/directives/list.ts", "../src/directives/nest.ts", "../src/directives/merge.ts"],
  "sourcesContent": ["import type { ParsedTemplate, TemplateExpIndex } from '../h';\n\n/**\n * Parsed Template Directives.\n * @internal\n */\nexport type ParsedTemplateDirectives<K = unknown, V = unknown> = Record<\n  keyof K,\n  V\n>;\n\n/**\n * An instance of a template directive expression.\n * @internal\n */\nexport interface TemplateDirectiveInstance<\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends Element = HTMLElement,\n> {\n  /**\n   * Node that the directive is attached to.\n   *\n   * Note: If this is a \"node\" type directive, it will be attached to a\n   * \"template\" element that serves as a placeholder.\n   */\n  node: DIRECTIVE_NODE;\n  /**\n   * Index position of the directive instance.\n   */\n  index: TemplateExpIndex;\n  /**\n   * Arguments provided to the directive.\n   */\n  args: DIRECTIVE_ARGS;\n}\n\n/**\n * Template directive's callback.\n * @internal\n */\nexport type TemplateDirectiveCallback<\n  DIRECTIVE_ARGS extends unknown[],\n  DIRECTIVE_NODE extends Element = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n> = (\n  template: PARSED_TEMPLATE,\n  instances: TemplateDirectiveInstance<DIRECTIVE_ARGS, DIRECTIVE_NODE>[],\n) => void;\n\n/**\n * Property that identifies an object as an instance of a template directive\n * expression.\n * @internal\n */\nexport const directiveId = '__cI4Mp6yr0__';\n\n/**\n * Create an \"attr\" template directive.\n * @param definition Template directive definition.\n */\nexport const createAttrTemplateDirective = <\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  DIRECTIVE_NODE extends Element = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n>(\n  callback: TemplateDirectiveCallback<\n    DIRECTIVE_ARGS,\n    DIRECTIVE_NODE,\n    PARSED_TEMPLATE\n  >,\n) => {\n  return (...args: DIRECTIVE_ARGS) => ({\n    id: directiveId,\n    type: 'attr',\n    callback,\n    args,\n  });\n};\n\n/**\n * Create a \"node\" template directive.\n * @param definition Template directive definition.\n */\nexport const createNodeTemplateDirective = <\n  DIRECTIVE_ARGS extends unknown[] = unknown[],\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n>(\n  callback: TemplateDirectiveCallback<\n    DIRECTIVE_ARGS,\n    HTMLTemplateElement,\n    PARSED_TEMPLATE\n  >,\n) => {\n  return (...args: DIRECTIVE_ARGS) => ({\n    id: directiveId,\n    type: 'node',\n    callback,\n    args,\n  });\n};\n", "import type { TemplateAttrsExp } from '../h';\n\n/**\n * Update attributes or properties on an element.\n * @param node Element whose attributes or properties need to be updated.\n * @param nodeAttrs Attributes and/or properties to update.\n *     The behaviour of the following properties have been altered to\n *     simplify the process of updating these values:\n *     - \"className\": A space separated list of CSS classnames that will be\n *                    appended to an element's class list.\n *     - \"style\"    : CSS inline styles that will be applied to the element.\n *                    Style names are expected to be camelCased.\n *     - \"dataset\"  : DOM string map of custom data attributes. The attributes\n *                    are expected to be camelCased.\n *\n */\nexport const attrs = (node: HTMLElement, nodeAttrs: TemplateAttrsExp): void => {\n  Object.entries(nodeAttrs).forEach(([name, value]) => {\n    switch (name) {\n      case 'className': {\n        (value as string).split(/\\s{1,}/).forEach((name) => {\n          const trimmedName = name.trim();\n          if (trimmedName) {\n            node.classList.add(trimmedName);\n          }\n        });\n        break;\n      }\n      case 'style':\n        Object.assign(node.style, value);\n        break;\n      case 'dataset':\n        Object.assign(node.dataset, value);\n        break;\n      default: {\n        const isAttr = name.startsWith('[') && name.endsWith(']');\n        if (isAttr) {\n          const attrName = name.substring(1, name.length - 1);\n          if (value === false) {\n            node.removeAttribute(attrName);\n          } else {\n            node.setAttribute(\n              attrName,\n              value === true ? '' : (value as string),\n            );\n          }\n        } else {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const currentPropValue = node[name] as unknown;\n\n          if (currentPropValue !== value) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            node[name] = value;\n          }\n        }\n      }\n    }\n  });\n};\n", "import type { TemplateAttrsExp } from '../h';\nimport { attrs } from './attrs';\n\n/**\n * A CSS class name.\n * @internal\n */\ntype ClassName = string;\n\n/**\n * An HTML element attribute name.\n *\n * Attribute names are expected to be in \"snake-case\".\n *\n * @internal\n */\ntype AttrNameSnakeCased = string;\n\n/**\n * An HTML element custom data attribute name.\n *\n * Custom data attribute names are expected to be in \"cameCase\".\n *\n * @internal\n */\ntype DataAttrNameCamelCased = string;\n\n/**\n * Wraps a node with a utility functions to simplify making changes to the\n * node.\n * @param node Node to wrap\n */\nexport const createRef = <NODE extends HTMLElement>(node: NODE) => {\n  const nodePlaceholder = new Text('');\n  let removed = false;\n\n  const replaceNode = () => {\n    if (removed) {\n      nodePlaceholder.replaceWith(node);\n      removed = false;\n    }\n  };\n\n  return {\n    /**\n     * Provided node.\n     */\n    node,\n    /**\n     *\n     * @param cssClassNames CSS class names to add or remove\n     */\n    classMap: (cssClassNames: Record<ClassName, boolean>) => {\n      Object.entries(cssClassNames).forEach(([className, active]) => {\n        if (active) {\n          node.classList.add(className);\n        } else {\n          node.classList.remove(className);\n        }\n      });\n    },\n    attrMap: (attrs: Record<AttrNameSnakeCased, string | boolean>) => {\n      Object.entries(attrs).forEach(([attrName, value]) => {\n        if (value === false) {\n          node.removeAttribute(attrName);\n        } else {\n          node.setAttribute(attrName, value === true ? '' : value);\n        }\n      });\n    },\n    dataMap: (dataset: Record<DataAttrNameCamelCased, boolean | string>) => {\n      Object.entries(dataset).forEach(([dataAttrName, value]) => {\n        if (value === false) {\n          delete node.dataset[dataAttrName];\n        } else {\n          node.dataset[dataAttrName] = value === true ? '' : value;\n        }\n      });\n    },\n    text: (textContent: string) => {\n      if (node.textContent !== textContent) {\n        node.textContent = textContent;\n      }\n    },\n    style: (style: Partial<CSSStyleDeclaration>) => attrs(node, { style }),\n    attrs: (elementAttrs: TemplateAttrsExp) => attrs(node, elementAttrs),\n    show: () => {\n      node.style.removeProperty('display');\n      replaceNode();\n    },\n    hide: () => {\n      node.style.setProperty('display', 'none');\n      replaceNode();\n    },\n    remove: () => {\n      if (!removed) {\n        node.replaceWith(nodePlaceholder);\n        removed = true;\n      }\n    },\n  };\n};\n", "import type { ElementRef } from '../h';\nimport { createAttrTemplateDirective } from '../helpers/create-template-directive';\nimport { createRef } from '../helpers/create-ref';\n\n/**\n * Name of the referenced element.\n * @internal\n */\ntype ReferencedElementName = string;\n\n/**\n * Ref directive type generator.\n */\nexport type RefDirective<\n  NODE_REFS extends { [P in keyof NODE_REFS]: NODE_REFS[P] },\n> = { [P in keyof NODE_REFS]: ElementRef<NODE_REFS[P]> };\n\n/**\n * Create a reference to an element.\n *\n * Example:\n * const tpl = html`\n * \t <form>\n *     <div>\n *       <label>Name:</label>\n *       <input type=\"text\">\n *     </div>\n *     <div>\n *       <button type=\"submit\" ${$ref('submitBtn')}>Submit</button>\n *     </div>\n *   </form>\n * `;\n * tpl.submitBtn.node.click();\n * tpl.submitBtn.attrMap({ disable: true });\n */\nexport const $ref = createAttrTemplateDirective<[ReferencedElementName]>(\n  (template, instances) => {\n    instances.forEach(({ node, args: [key] }) => {\n      Object.defineProperty(template, key, { value: createRef(node) });\n    });\n  },\n);\n", "import { createNodeTemplateDirective } from '../helpers/create-template-directive';\n\n/**\n * A name for the updatable text node.\n * @internal\n */\ntype UpdatableTextNodeName = string;\n\n/**\n * Default text content for the text node.\n * @internal\n */\ntype DefaultTextContent = string;\n\n/**\n * Text directive type generator.\n */\nexport type TextDirective<NODE_NAME extends UpdatableTextNodeName> = Record<\n  NODE_NAME,\n  string\n>;\n\n/**\n * Creates an updatable text node.\n *\n * Example:\n * const tpl = html`\n *   <div>\n *     <p>${$text('label', 'Optional default value')}</p>\n *   </div>\n * `;\n * tpl.label = 'Lorem ipsum...';\n */\nexport const $text = createNodeTemplateDirective<\n  [UpdatableTextNodeName] | [UpdatableTextNodeName, DefaultTextContent]\n>((template, instances) => {\n  instances.forEach(({ node, args: [nodeKey, content] }) => {\n    const textNode = new Text(content || '');\n    node.replaceWith(textNode);\n    Object.defineProperty(template, nodeKey, {\n      enumerable: true,\n      get: () => textNode.textContent,\n      set: (value: string) => {\n        const stringifiedValue = String(value);\n        if (textNode.textContent !== stringifiedValue) {\n          textNode.textContent = stringifiedValue;\n        }\n      },\n    });\n  });\n});\n", "/**\n * Is `arg` a plain object?\n *\n * This check is meant to guard against honest mistakes not scenarios where the\n * user is deliberately trying pass a value off as a plain object.\n * @internal\n * @param arg Argument to check.\n */\nexport const isPlainObject = (arg: unknown): arg is object =>\n  Boolean(\n    arg && (arg.constructor === Object || Object.getPrototypeOf(arg) === null),\n  );\n", "import type {\n  TemplateDirectiveCallback,\n  TemplateDirectiveInstance,\n  ParsedTemplateDirectives,\n  createAttrTemplateDirective,\n  createNodeTemplateDirective,\n} from './helpers/create-template-directive';\nimport { attrs } from './helpers/attrs';\nimport { createRef } from './helpers/create-ref';\nimport { isPlainObject } from './helpers/is-plain-object';\nimport { isTemplateDirective } from './helpers/is-template-directive';\nimport { isParsedTemplate } from './helpers/is-parsed-template';\n\n/**\n * A template that has been parsed by h.\n */\nexport type ParsedTemplate<\n  NODE extends Node = HTMLElement,\n  DIRECTIVES extends ParsedTemplateDirectives = ParsedTemplateDirectives,\n> = {\n  $: {\n    id: typeof parsedTemplateId;\n    callbacks: TemplateCallbackSet;\n    node: NODE;\n  };\n} & DIRECTIVES;\n\n/**\n * An \"attributes\" template expression.\n */\nexport type TemplateAttrsExp<\n  CUSTOM_ATTRS extends { [P in keyof CUSTOM_ATTRS]: CUSTOM_ATTRS[P] } = object,\n> = {\n  /**\n   * CSS classes that will be appended to the element.\n   */\n  className?: string;\n  /**\n   * CSS inline styles for the element. The properties are expected to be in\n   * camelCase.\n   */\n  style?: Partial<CSSStyleDeclaration>;\n  /**\n   * A DOM string map of custom data attribute properties set on the element.\n   * The properties are expected to be in camelCase.\n   */\n  dataset?: HTMLOrSVGElement['dataset'];\n  /**\n   * Other attributes or properties that will be assigned to the element.\n   */\n  [attr: string]: unknown;\n} & Partial<GlobalEventHandlers> &\n  Partial<ARIAMixin> &\n  Partial<InnerHTML> &\n  Partial<Node> &\n  Partial<Element> &\n  CUSTOM_ATTRS;\n\n/**\n * A \"directive\" template expression.\n */\nexport type TemplateDirectiveExp = ReturnType<\n  | ReturnType<typeof createAttrTemplateDirective>\n  | ReturnType<typeof createNodeTemplateDirective>\n>;\n\nexport type TemplateCallbackRef<\n  NODE extends HTMLElement = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n> = ElementRef<NODE> & { tpl: PARSED_TEMPLATE };\n\n/**\n * A \"callback\" template expression.\n *\n * Notes:\n * - All callbacks expressions are collected into a set called \"$.callbacks\"\n *   that is attached to a parsed template.\n * - This callback is not executed until $.callbacks.run() is called. This\n *   allows you to control when callbacks which allows for the creation of more\n *   complex closures.\n * - If the callback returns false, it will be removed from \"$.callbacks\" the\n *   first time it is executed (i.e. one-off callbacks expressions).\n */\nexport type TemplateCallbackExp<\n  NODE extends HTMLElement = HTMLElement,\n  PARSED_TEMPLATE extends ParsedTemplate = ParsedTemplate,\n> = (ref: TemplateCallbackRef<NODE, PARSED_TEMPLATE>) => unknown;\n\n/**\n * Valid template expressions.\n * @internal\n */\ntype TemplateExps =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | Node\n  | TemplateAttrsExp\n  | TemplateCallbackExp\n  | TemplateDirectiveExp\n  | ParsedTemplate\n  | (\n      | string\n      | number\n      | boolean\n      | null\n      | undefined\n      | Node\n      | TemplateAttrsExp\n      | TemplateCallbackExp\n      | TemplateDirectiveExp\n      | ParsedTemplate\n    )[];\n\n/**\n * An \"attribute\" template expression that has been tagged and is ready for\n * interpolation.\n * @internal\n */\ntype TaggedTemplateAttrsExp = string;\n\n/**\n * A \"node\" template expression that has been tagged and is ready for\n * interpolation.\n * @internal\n */\ntype TaggedNodeExp = string;\n\n/**\n * The index position of a template expression.\n * @internal\n */\nexport type TemplateExpIndex = number;\n\n/**\n * A map of template expression index position to template expression.\n * @internal\n */\ntype TaggedExpMap = Map<\n  TemplateExpIndex,\n  Node | TemplateCallbackExp | TemplateAttrsExp | TemplateDirectiveExp\n>;\n\n/**\n * A wrapper around an HTML element that provides additional utility functions.\n */\nexport type ElementRef<NODE extends HTMLElement = HTMLElement> = ReturnType<\n  typeof createRef<NODE>\n>;\n\n/**\n * An internal property to identify parsed template objects.\n * @internal\n */\nexport const parsedTemplateId = '__PzroJBb1g__';\n\n/**\n * Tags an \"attributes\" template expression for interpolation.\n *\n * @internal\n * @param i Template expression index position.\n */\nconst tagAttrsExp = (i: TemplateExpIndex): TaggedTemplateAttrsExp =>\n  `data-FHF7Sj5kD1S-${i}`;\n\n/**\n * Tags a \"node\" template expression for interpolation.\n * @internal\n * @param i Template expression index position.\n */\nconst tagNodeExp = (i: TemplateExpIndex): TaggedNodeExp =>\n  `<template ${tagAttrsExp(i)}></template>`;\n\n/**\n * Set of all callback expressions in a parsed template.\n * @internal\n */\nclass TemplateCallbackSet extends Set<() => unknown> {\n  /**\n   * Execute all callbacks.\n   */\n  run() {\n    this.forEach((callback) => {\n      if (callback() === false) {\n        this.delete(callback);\n      }\n    });\n  }\n\n  /**\n   * Execute all callbacks inside \"requestAnimationFrame\"\n   */\n  runAsync() {\n    window.requestAnimationFrame(() => this.run());\n  }\n}\n\n/**\n * Tags all expressions in a template.\n * @internal\n * @param htmlStrings Template literal HTML strings.\n * @param templateExps Template literal expressions.\n */\nconst tag = (\n  htmlStrings: TemplateStringsArray,\n  templateExps: TemplateExps[],\n): {\n  taggedTemplate: HTMLTemplateElement;\n  taggedExps: TaggedExpMap;\n  createErrorTemplate: () => string;\n} => {\n  const taggedExps: TaggedExpMap = new Map();\n\n  // Intentionally using a `template` instead of something like a `div` as we\n  // do not want any events from the elements to trigger while we're parsing the\n  // template.\n  const taggedTemplate = document.createElement('template');\n\n  const createErrorTemplate = () => {\n    let expIndex = 0;\n    return htmlStrings.reduce((chunks, chunk, templateExpsIndex) => {\n      if (templateExpsIndex === 0) {\n        return chunk;\n      }\n      const currentExp = templateExps[templateExpsIndex - 1];\n      let exp = '';\n      if (Array.isArray(currentExp)) {\n        exp = `\\${[${currentExp.map((_, i) => i).join(',')}]}`;\n        expIndex += currentExp.length;\n      } else {\n        exp = `\\${${expIndex}}`;\n        expIndex++;\n      }\n      return `${chunks}${exp}${chunk}`;\n    }, '');\n  };\n\n  let expCount = -1;\n  taggedTemplate.innerHTML = htmlStrings\n    .reduce((combinedHtmlStrings, htmlString, expIndex) => {\n      let htmlChunk = `${combinedHtmlStrings}${htmlString}`;\n\n      if (!(expIndex in templateExps)) return htmlChunk;\n\n      const currentExp = templateExps[expIndex] as TemplateExps;\n\n      ([] as TemplateExps[]).concat(currentExp).forEach((exp) => {\n        expCount++;\n\n        // TODO: should we escape expression automatically?\n\n        const expType = typeof exp;\n        if (exp === null || exp === undefined) {\n          // Do nothing\n        } else if (\n          expType === 'string' ||\n          expType === 'number' ||\n          expType === 'boolean'\n        ) {\n          htmlChunk += exp;\n        } else if (expType === 'function') {\n          taggedExps.set(expCount, exp as TemplateCallbackExp);\n          htmlChunk += tagAttrsExp(expCount);\n        } else if (exp instanceof Node) {\n          taggedExps.set(expCount, exp as Node);\n          htmlChunk += tagNodeExp(expCount);\n        } else if (isParsedTemplate(exp)) {\n          taggedExps.set(expCount, exp.$.node);\n          htmlChunk += tagNodeExp(expCount);\n        } else if (isTemplateDirective(exp)) {\n          taggedExps.set(expCount, exp);\n          htmlChunk +=\n            exp.type === 'attr' ? tagAttrsExp(expCount) : tagNodeExp(expCount);\n        } else if (isPlainObject(exp)) {\n          taggedExps.set(expCount, exp as TemplateAttrsExp);\n          htmlChunk += tagAttrsExp(expCount);\n        } else {\n          throw new Error(\n            `Invalid template expression at index ${expCount}:\\n` +\n              createErrorTemplate(),\n          );\n        }\n      });\n      return htmlChunk;\n    }, '')\n    // The combined HTML strings must be trimmed to remove meaningless\n    // whitespace characters. If not, given a string like this:\n    // h`\n    //   <p>Hello</p>\n    // `\n    // \"container.childNodes.length\" > 1 even though the only relevant node in\n    // that string is the \"p\" element.\n    .trim();\n\n  return { taggedTemplate, taggedExps, createErrorTemplate };\n};\n\n/**\n * Interpolate a tagged template with the provided template expressions.\n * @internal\n * @param template Tagged template\n */\nconst interpolate = <\n  NODE extends Node = HTMLElement,\n  DIRECTIVES extends ParsedTemplateDirectives = ParsedTemplateDirectives,\n>({\n  taggedTemplate,\n  taggedExps,\n  createErrorTemplate,\n}: ReturnType<typeof tag>): ParsedTemplate<NODE, DIRECTIVES> => {\n  type Template = ParsedTemplate<NODE, DIRECTIVES>;\n\n  const fragment = taggedTemplate.content.cloneNode(true) as DocumentFragment;\n  const directives = new Map<\n    TemplateDirectiveExp['callback'],\n    TemplateDirectiveInstance[]\n  >();\n\n  const refs: TemplateCallbackRef[] = [];\n  const callbackExps = new TemplateCallbackSet();\n  taggedExps.forEach((exp, expIndex) => {\n    const taggedAttr = tagAttrsExp(expIndex);\n\n    const node = fragment.querySelector<HTMLElement>(`[${taggedAttr}]`);\n    if (!node) {\n      const template = document.createElement('template');\n      template.append(fragment);\n      console.error(template);\n      throw new Error(\n        `Unable to interpolate expression at index ${expIndex}. ` +\n          `This could also have occurred because some prior expression was ` +\n          `mismatched.\\n${createErrorTemplate()}`,\n      );\n    }\n\n    node.removeAttribute(taggedAttr);\n\n    if (exp instanceof Node) {\n      node.replaceWith(exp);\n    } else if (isTemplateDirective(exp)) {\n      const { args, callback } = exp;\n      const instances = directives.get(callback) || [];\n      instances.push({ node, index: expIndex, args });\n      directives.set(callback, instances);\n    } else if (typeof exp === 'function') {\n      const ref = createRef(node) as TemplateCallbackRef;\n      refs.push(ref);\n      callbackExps.add(() => exp(ref));\n    } else {\n      attrs(node, exp as TemplateAttrsExp);\n    }\n  });\n\n  const template = new Proxy<Template>(\n    Object.defineProperties({} as Template, {\n      $: {\n        value: {\n          id: parsedTemplateId,\n          callbacks: callbackExps,\n          node:\n            fragment.childNodes.length === 1\n              ? fragment.childNodes[0]\n              : fragment,\n        },\n        enumerable: false,\n      },\n    }),\n    {\n      defineProperty(target, key, descriptor) {\n        if (key in target) {\n          throw new Error(`Duplicate template key: \"${String(key)}\"`);\n        }\n        Object.defineProperty(target, key, descriptor);\n        return true;\n      },\n    },\n  );\n\n  // Attach parsed template to all callback refs.\n  refs.forEach((ref) => Object.defineProperty(ref, 'tpl', { value: template }));\n\n  directives.forEach((instances, callback) => {\n    (callback as unknown as TemplateDirectiveCallback<unknown[]>)(\n      template as unknown as ParsedTemplate,\n      instances,\n    );\n  });\n\n  return template;\n};\n\n/**\n * Parse an HTML template\n * @param htmlStrings HTML strings.\n * @param templateExps Template expressions\n * @returns A parsed HTML template.\n */\nexport const h = <\n  NODE extends Node = DocumentFragment,\n  DIRECTIVES extends ParsedTemplateDirectives = ParsedTemplateDirectives,\n>(\n  htmlStrings: TemplateStringsArray,\n  ...templateExps: TemplateExps[]\n): ReturnType<typeof interpolate<NODE, DIRECTIVES>> => {\n  return interpolate(tag(htmlStrings, templateExps));\n};\n", "import { type ParsedTemplate, parsedTemplateId } from '../h';\nimport { isPlainObject } from './is-plain-object';\n\n/**\n * Is `arg` a parsed template?\n * @internal\n * @param arg Argument to check.\n */\nexport const isParsedTemplate = (arg: unknown): arg is ParsedTemplate => {\n  return (\n    isPlainObject(arg) &&\n    '$' in arg &&\n    isPlainObject(arg.$) &&\n    'id' in arg.$ &&\n    arg.$.id === parsedTemplateId\n  );\n};\n", "import type { ParsedTemplate } from '../h';\nimport { isParsedTemplate } from './is-parsed-template';\n\n/**\n * Node or template for each list item.\n * @internal\n */\nexport type ListNode = HTMLElement | ParsedTemplate;\n\n/**\n * A key that uniquely identifies each list item.\n * @internal\n */\ntype ListItemKey = string;\n\n/**\n * Index position of each list item.\n */\ntype ListItemIndex = number;\n\n/**\n * Callback to generate a unique key for each list item.\n * @internal\n */\ninterface ListKeyCallback<ITEM> {\n  (item: ITEM, data: { key: ListItemKey; index: ListItemIndex }): ListItemKey;\n}\n\n/**\n * Callback to generate each list item.\n * @internal\n */\ninterface ListNodeCallback<ITEM, NODE extends ListNode> {\n  (item: ITEM, data: { key: ListItemKey; index: ListItemIndex }): NODE;\n}\n\n/**\n * Callback that is executed on each list item regardless of whether the item\n * has been updated or not.\n * @internal\n */\ninterface ListRefCallback<ITEM, NODE extends ListNode> {\n  (\n    el: NODE,\n    item: ITEM,\n    data: { key: ListItemKey; index: ListItemIndex },\n  ): unknown;\n}\n\n/**\n * Parameters for createList\n * @internal\n */\ninterface ListParams<ITEM, NODE extends ListNode> {\n  /**\n   * Container that houses the entire list.\n   */\n  container: HTMLElement;\n  /**\n   * Items to generate.\n   */\n  items:\n    | Map<unknown, ITEM>\n    | Set<ITEM>\n    | ITEM[]\n    | Record<string | number | symbol, ITEM>;\n  /**\n   * List item node or template.\n   */\n  node: ListNodeCallback<ITEM, NODE>;\n  /**\n   * List item ref callback.\n   */\n  ref?: ListRefCallback<ITEM, NODE>;\n  /**\n   * List item key callback.\n   */\n  key?: ListKeyCallback<ITEM>;\n  /**\n   * Name of the list item key attribute.\n   */\n  keyName?: string;\n  /**\n   * Name of the list item index attribute.\n   */\n  indexKeyName?: string;\n}\n\n/**\n * Name of the property that is used to store a reference to a list item's\n * parsed template.\n * @internal\n */\nconst refParsedTemplateKey = '__un3Mvl07V__';\n\n/**\n * Create a list of nodes.\n */\nexport const createList = <ITEM, NODE extends ListNode>({\n  container,\n  items,\n  node: createNode,\n  ref,\n  key: createKey = (_, { key }) => String(key),\n  keyName = 'data-h-list-key',\n  indexKeyName = 'data-h-list-index',\n}: ListParams<ITEM, NODE>): void => {\n  const entries = Array.isArray(items)\n    ? items.entries()\n    : items instanceof Map\n      ? items\n      : items instanceof Set\n        ? Array.from(items).entries()\n        : Object.entries(items);\n\n  // TODO: must create tests for checking that items are appended in the right order\n\n  const existingElements = new Map<string, Element>();\n  for (const element of container.querySelectorAll(`:scope > [${keyName}]`)) {\n    existingElements.set(element.getAttribute(keyName) as string, element);\n  }\n\n  let index = 0;\n  for (const [itemKey, item] of entries) {\n    const key = String(itemKey);\n    const elementKey = String(createKey(item, { key, index }));\n\n    const element =\n      existingElements.get(elementKey) || createNode(item, { key, index });\n\n    existingElements.delete(elementKey);\n\n    const node = isParsedTemplate(element) ? element.$.node : element;\n\n    if (!(node instanceof Element)) {\n      throw new Error('Each list item must contain only a single root node');\n    }\n\n    const wrongOrder =\n      Math.abs(Number(node.getAttribute(indexKeyName) || Infinity) - index) > 0;\n\n    if (wrongOrder) {\n      node.remove();\n      node.setAttribute(keyName, elementKey);\n      node.setAttribute(indexKeyName, String(index));\n      container.append(node);\n    }\n\n    if (ref) {\n      // If the element is a parsed template, we need to store it so that if\n      // ref is called on an existing element, we can still retrieve the\n      // original parsed template from the DOM node.\n      if (isParsedTemplate(element)) {\n        Object.defineProperty(node, refParsedTemplateKey, {\n          enumerable: false,\n          value: element,\n        });\n      }\n      const refElement = (\n        refParsedTemplateKey in node ? node[refParsedTemplateKey] : node\n      ) as NODE;\n\n      ref(refElement, item, { key, index });\n    }\n\n    index++;\n  }\n\n  // Remove any other elements that were not found in \"items\"\n  existingElements.forEach((element) => element.remove());\n};\n", "import { createAttrTemplateDirective } from '../helpers/create-template-directive';\nimport { ListNode, createList } from '../helpers/create-list';\n\n/**\n * Name of the updatable list.\n * @internal\n */\ntype ListName = string;\n\n/**\n * List data.\n * @internal\n */\ntype ListData<ITEM, ELEMENT extends ListNode> = {\n  name: ListName;\n} & Omit<Parameters<typeof createList<ITEM, ELEMENT>>[0], 'container'>;\n\n/**\n * List directive type generator.\n */\nexport type ListDirective<\n  LISTS extends Record<ListName, Parameters<typeof createList>[0]['items']>,\n> = LISTS;\n\n/**\n * Create a list of nodes.\n *\n * Example:\n * const tasks = new Map([\n *   ['gudjIy', \"Task 1\"],\n *   ['gCoKL9', \"Task 2\"],\n *   ['e16Amr', \"Task 3\"],\n * ]);\n *\n * const tpl = html`\n *   <div\n *     ${$list({\n *       name: 'tasks',\n *       items: new Map([\n *         ['gudjIy', \"Task 1\"],\n *         ['gCoKL9', \"Task 2\"],\n *         ['e16Amr', \"Task 3\"],\n *       ]),\n *       key: (task, { key, index }) => key,\n *     })\n *   }>\n *   </div>\n * `;\n *\n * tasks.delete('gCoKL9');\n * tpl.tasks = tasks; // Updates DOM\n *\n * @param args List data.\n */\nexport const $list = <ITEM, ELEMENT extends ListNode>(\n  args: ListData<ITEM, ELEMENT>,\n) => {\n  return createAttrTemplateDirective<[ListData<ITEM, ELEMENT>]>(\n    (template, instances) => {\n      instances.forEach(({ node, args: [opts] }) => {\n        const { name } = opts;\n        const list = { ...opts, container: node };\n        Object.defineProperty(template, name, {\n          enumerable: true,\n          get: () => list.items,\n          set: (\n            items: Parameters<typeof createList<ITEM, ELEMENT>>[0]['items'],\n          ) => {\n            list.items = items;\n            createList(list);\n          },\n        });\n        createList(list);\n      });\n    },\n  )(args);\n};\n", "import type { ParsedTemplate } from '../h';\nimport { createNodeTemplateDirective } from '../helpers/create-template-directive';\n\n/**\n * Name of the nested template.\n * @internal\n */\ntype NestedTemplateName = string;\n\n/**\n * Nest directive type generator.\n */\nexport type NestDirective<\n  NESTED_TEMPLATE extends { [P in keyof NESTED_TEMPLATE]: ParsedTemplate },\n> = NESTED_TEMPLATE;\n\n/**\n * Creates a reference to another parsed template.\n *\n * Example:\n *\n * const Component = () => html`\n *   <div>\n *     <p>${$text('label')}</p>\n *   </div>\n * `;\n *\n * const tpl = html`\n *   <div>\n *     ${$nest('componentA', Component())}\n *     ${$nest('componentB', Component())}\n *   </div>\n * `;\n *\n * tpl.componentA.label = 'Something...';\n * tpl.componentB.label = 'Else...';\n */\nexport const $nest = createNodeTemplateDirective<\n  [NestedTemplateName, ParsedTemplate]\n>((template, instances) => {\n  instances.forEach(({ node, args: [name, componentTemplate] }) => {\n    node.appendChild(componentTemplate.$.node);\n    Object.defineProperty(template, name, {\n      value: componentTemplate,\n      enumerable: true,\n    });\n  });\n});\n", "import type { ParsedTemplate } from '../h';\nimport { createNodeTemplateDirective } from '../helpers/create-template-directive';\n\n/**\n * Merge directive options.\n * @internal\n */\ntype MergeOptions = {\n  /**\n   * Merge template callback expressions? The default is false.\n   */\n  callbacks?: boolean;\n  /**\n   * Merge template directive properties? The default is true.\n   */\n  directives?: boolean;\n};\n\n/**\n * Merge directive type generator.\n */\nexport type MergeDirective<\n  M_TEMPLATE extends { [P in keyof M_TEMPLATE]: ParsedTemplate },\n> = M_TEMPLATE;\n\n/**\n * Combines all properties of another parsed template into this parsed template.\n *\n * ! Note: If there is a property collision, the template parser will generate !\n * ! an exception.                                                             !\n *\n * Example:\n *\n * const Input = (name, label) => html`\n *   <div>\n *     <label>${label}</label>\n *     <input type=\"text\" ${{ name }} ${$ref(name)}>\n *   </div>\n * `;\n *\n * const tpl = html`\n *   <form>\n *     ${Input('firstName', 'First name')}\n *     ${Input('lastName', 'Last name')}\n *     <button type=\"submit\" ${$ref('submitBtn')}>Submit</button>\n *   </form>\n * `;\n *\n * tpl.firstName.node.value = 'John';\n * tpl.lastName.node.value = 'Smith';\n * tpl.submitBtn.node.click();\n */\nexport const $merge = createNodeTemplateDirective<\n  [ParsedTemplate, MergeOptions?]\n>((template, instances) => {\n  instances.forEach(({ node, args: [templateToMerge, opts = {}] }) => {\n    node.replaceWith(templateToMerge.$.node);\n\n    const {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      $,\n      ...directives\n    } = Object.getOwnPropertyDescriptors(templateToMerge);\n\n    if (opts.directives !== false) {\n      Object.defineProperties(template, directives);\n    }\n\n    if (opts.callbacks === true) {\n      templateToMerge.$.callbacks.forEach((callback) => {\n        template.$.callbacks.add(callback);\n      });\n    }\n  });\n});\n\n/**\n * Combines all properties of another parsed template into this parsed template.\n *\n * This directive will merge everything from the template (including its\n * template callback expressions).\n *\n * ! Note: If there is a property collision, the template parser will generate !\n * ! an exception.                                                             !\n *\n * Example:\n *\n * const Input = (name, label) => html`\n *   <div>\n *     <label>${label}</label>\n *     <input type=\"text\" ${{ name }} ${$ref(name)}>\n *   </div>\n * `;\n *\n * const tpl = html`\n *   <form>\n *     ${Input('firstName', 'First name')}\n *     ${Input('lastName', 'Last name')}\n *     <button type=\"submit\" ${$ref('submitBtn')}>Submit</button>\n *   </form>\n * `;\n *\n * tpl.firstName.node.value = 'John';\n * tpl.lastName.node.value = 'Smith';\n * tpl.submitBtn.node.click();\n */\nexport const $mergeAll = (template: ParsedTemplate) =>\n  $merge(template, { callbacks: true, directives: true });\n"],
  "mappings": "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",
  "names": ["directiveId", "createAttrTemplateDirective", "callback", "args", "createNodeTemplateDirective", "attrs", "node", "nodeAttrs", "name", "value", "trimmedName", "attrName", "createRef", "node", "nodePlaceholder", "removed", "replaceNode", "cssClassNames", "className", "active", "attrs", "attrName", "value", "dataset", "dataAttrName", "textContent", "style", "elementAttrs", "$ref", "createAttrTemplateDirective", "template", "instances", "node", "key", "createRef", "$text", "createNodeTemplateDirective", "template", "instances", "node", "nodeKey", "content", "textNode", "value", "stringifiedValue", "isPlainObject", "arg", "parsedTemplateId", "isParsedTemplate", "arg", "isPlainObject", "parsedTemplateId", "refParsedTemplateKey", "createList", "container", "items", "createNode", "ref", "createKey", "_", "key", "keyName", "indexKeyName", "entries", "existingElements", "element", "index", "itemKey", "item", "elementKey", "node", "isParsedTemplate", "refElement", "$list", "args", "createAttrTemplateDirective", "template", "instances", "node", "opts", "name", "list", "items", "createList", "$nest", "createNodeTemplateDirective", "template", "instances", "node", "name", "componentTemplate", "$merge", "createNodeTemplateDirective", "template", "instances", "node", "templateToMerge", "opts", "$", "directives", "callback", "$mergeAll"]
}
